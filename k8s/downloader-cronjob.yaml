apiVersion: batch/v1
kind: CronJob
metadata:
  name: playlister-downloader
  namespace: playlister
spec:
  schedule: "0 6 * * *"  # 6 AM daily
  concurrencyPolicy: Forbid  # Prevent overlapping jobs
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 1
  jobTemplate:
    spec:
      backoffLimit: 2
      template:
        spec:
          restartPolicy: OnFailure
          containers:
          - name: runner
            image: ianhowell.azurecr.io/playlister-downloader:latest
            imagePullPolicy: IfNotPresent
            command: ["/bin/bash", "-c"]
            args:
            - |
              set -euo pipefail

              # Configure git
              git config --global user.name "$GIT_USER_NAME"
              git config --global user.email "$GIT_USER_EMAIL"

              # SSH setup for pushing
              mkdir -p ~/.ssh
              echo "$GIT_SSH_KEY" > ~/.ssh/id_rsa
              chmod 600 ~/.ssh/id_rsa
              ssh-keyscan github.com >> ~/.ssh/known_hosts 2>/dev/null || true

              # Ensure repo is initialized (first run safety)
              if [ ! -d "/downloader/mnt/.git" ]; then
                echo "Initializing repo in /downloader/mnt"
                cd /downloader/mnt
                git init
                git remote add origin "$GIT_URL" || true
                git fetch origin main || true
                # If remote exists, align with it; otherwise create main
                if git ls-remote --exit-code origin main >/dev/null 2>&1; then
                  git checkout -B main
                  git reset --hard origin/main
                else
                  git checkout -B main
                fi
              fi

              # File lock to avoid races with any other accidental writer
              cd /downloader/mnt
              exec 200>.downloader.lock
              if ! flock -n 200; then
                echo "Another process holds the lock; exiting"
                exit 0
              fi

              # Pull latest before writing
              git remote set-url origin "$GIT_URL" || true
              git fetch origin main || true
              if git ls-remote --exit-code origin main >/dev/null 2>&1; then
                git checkout -B main
                git reset --hard origin/main
              else
                git checkout -B main
              fi

              # Run downloader (writes db.json and updates config.json in /downloader/mnt)
              cd /downloader
              ./downloader

              # Commit and push if changed
              cd /downloader/mnt
              if ! git diff --quiet || ! git diff --cached --quiet; then
                git add .
                git commit -m "Data update: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
                # Simple push with one retry in case of race with external writer
                if ! git push origin main; then
                  echo "Push failed; attempting one-time rebase-and-push"
                  git fetch origin main
                  git pull --rebase origin main || true
                  git push origin main
                fi
              else
                echo "No changes to commit"
              fi
            env:
            - name: GIT_USER_NAME
              valueFrom:
                secretKeyRef:
                  name: playlister-secrets
                  key: git-user-name
            - name: GIT_USER_EMAIL
              valueFrom:
                secretKeyRef:
                  name: playlister-secrets
                  key: git-user-email
            - name: GIT_SSH_KEY
              valueFrom:
                secretKeyRef:
                  name: playlister-secrets
                  key: git-ssh-key
            - name: GIT_URL
              valueFrom:
                secretKeyRef:
                  name: playlister-secrets
                  key: git-url
            volumeMounts:
            - name: data
              mountPath: /downloader/mnt
            - name: api-key
              mountPath: /downloader/API_KEY
              subPath: api-key
              readOnly: true
          volumes:
          - name: data
            persistentVolumeClaim:
              claimName: playlister-data
          - name: api-key
            secret:
              secretName: playlister-secrets
              items:
              - key: api-key
                path: api-key